use heck::{ToKebabCase, ToShoutySnakeCase};
use proc_macro2::{Span, TokenStream};
use quote::{quote, ToTokens};
use std::fmt::Display;
use syn::{
    meta::ParseNestedMeta, parse::Parse, spanned::Spanned, Error, Expr, ExprLit, Lit, LitChar,
    LitStr, Meta, Path, Token, Type,
};

/// Helper for determining if a type is likely bool
pub fn type_is_bool(ty: &Type) -> bool {
    match ty {
        Type::Path(typepath) => typepath.qself.is_none() && typepath.path.is_ident("bool"),
        _ => false,
    }
}

/// Helper for determining if a type is likely Option<...>
pub fn type_is_option(ty: &Type) -> bool {
    fn path_is_option(path: &Path) -> bool {
        path.leading_colon.is_none()
            && path.segments.len() == 1
            && path.segments.first().unwrap().ident == "Option"
    }

    match ty {
        Type::Path(typepath) => typepath.qself.is_none() && path_is_option(&typepath.path),
        _ => false,
    }
}

/// Helper for reading a required value, which comes after a key, during `.parse_nested_meta`
pub fn parse_required_value<T: Parse>(meta: ParseNestedMeta<'_>) -> Result<T, Error> {
    let t: T = meta.value()?.parse()?;
    Ok(t)
}

/// Helper for reading an optional value, which may come after a key, during `.parse_nested_meta`
pub fn parse_optional_value<T: Parse>(meta: ParseNestedMeta<'_>) -> Result<Option<T>, Error> {
    if meta.input.is_empty() || meta.input.peek(Token![,]) {
        Ok(None)
    } else {
        Ok(Some(parse_required_value::<T>(meta)?))
    }
}

/// Helper for making a default short flag for a field
pub fn make_short(ident: &impl Display, span: Span) -> Option<LitChar> {
    let string = ident.to_string();
    if string.is_empty() {
        return None;
    }
    let first = string.to_lowercase().chars().next().unwrap();
    Some(LitChar::new(first, span))
}

/// Helper for making a default long flag for a field
pub fn make_long(ident: &impl Display, span: Span) -> Option<LitStr> {
    let string = ident.to_string();
    if string.is_empty() {
        return None;
    }
    let kebab = string.to_kebab_case();
    Some(LitStr::new(&kebab, span))
}

/// Helper for making a default env flag for a field
pub fn make_env(ident: &impl Display, span: Span) -> Option<LitStr> {
    let string = ident.to_string();
    if string.is_empty() {
        return None;
    }
    let snake = string.to_shouty_snake_case();
    Some(LitStr::new(&snake, span))
}

/// Helper for setting a parameter that should only be set once, during `.parse_nested_meta`
pub fn set_once<T: Spanned>(
    context: &Path,
    param: &mut Option<T>,
    val: Option<T>,
) -> Result<(), Error> {
    if let Some(param) = param.as_ref() {
        let mut error = Error::new(
            context.span(),
            format!("{} cannot be specified twice", context.get_ident().unwrap()),
        );
        error.combine(Error::new(param.span(), "Earlier specified here"));
        return Err(error);
    }
    *param = val;
    Ok(())
}

/// Helper for appending a doc string attribute to the description string, if it is a doc string attribute.
// Based on code here: https://github.com/cyqsimon/documented/blob/e9a465c9e1666839ea08efbe9ce54480d7ee769f/documented-derive/src/lib.rs#L411
pub fn maybe_append_doc_string(
    description: &mut Option<String>,
    attr_meta: &Meta,
) -> Result<(), Error> {
    let doc_expr = match attr_meta {
        Meta::NameValue(ref name_value) if name_value.path.is_ident("doc") => &name_value.value,
        _ => return Ok(()),
    };

    let lit = match doc_expr {
        Expr::Lit(ExprLit {
            lit: Lit::Str(s), ..
        }) => s.value(),
        other => {
            return Err(Error::new(
                other.span(),
                "Doc comment is not a string literal",
            ))
        }
    };

    // Split by any newlines pre-existing in the string.
    // Trim any whitespace around those. Then add the newlines back.
    // Terminate with one newline
    let mut trimmed = lit
        .split('\n')
        .map(|line| line.trim())
        .fold(String::new(), |s, line| s + line + "\n");
    // Pop the extra newline
    trimmed.pop();

    // Add to description
    if let Some(desc) = description.as_mut() {
        desc.push('\n');
        desc.push_str(&trimmed);
    } else {
        // Just store this as the description
        *description = Some(trimmed);
    }
    Ok(())
}

/// Helper for turning values Option<String> (or Option<LitStr>) into Option<&'static str> in code generated by quote! macro
pub fn quote_opt<T: ToTokens>(src: &Option<T>) -> TokenStream {
    if let Some(string) = src.as_ref() {
        quote! { Some(#string) }
    } else {
        quote! { None }
    }
}

/// Helper for turning values Option<String> (or Option<LitStr>) into Option<conf::CowStr> in code generated by quote! macro
pub fn quote_opt_into<T: ToTokens>(src: &Option<T>) -> TokenStream {
    if let Some(string) = src.as_ref() {
        quote! { Some(#string.into()) }
    } else {
        quote! { None }
    }
}
